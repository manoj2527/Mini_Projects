#lang racket
(require "declarations.rkt")
(provide buildTree)
(provide calcForces)
(provide moveparticles)
;;seperate seperates the box(into 4 quadrants with particles)
(define (seperate box pl)
  (cond ((null? pl) (list null null null null))
        (#t (let* ((x (vec-x (particle-posn (car pl))))
                   (y (vec-y (particle-posn (car pl))))
                   (mdx (/ (+ (bbox-llx box) (bbox-rux box)) 2))
                   (mdy (/ (+ (bbox-lly box) (bbox-ruy box)) 2))
                   (rest (seperate box (cdr pl))))
              (cond ((and (< x mdx) (>= x (bbox-llx box)) (>= y mdy) (<= y (bbox-ruy box)))
                     (cons  (cons (car pl) (car rest)) (cdr rest)))
                    ((and (>= x mdx) (<= x (bbox-rux box)) (>= y mdy) (<= y (bbox-ruy box)))
                     (list (car rest) (cons (car pl) (cadr rest)) (caddr rest) (cadddr rest)))
                    ((and (>= x (bbox-llx box)) (< x mdx) (>= y (bbox-lly box)) (< y mdy))
                     (list (car rest) (cadr rest) (cons (car pl) (caddr rest)) (cadddr rest)))
                    ((and (>= x mdx) (<= x (bbox-rux box)) (>= y (bbox-lly box)) (< y mdy))
                     (list (car rest) (cadr rest) (caddr rest) (cons (car pl) (cadddr rest)))))))))
;;total mass in square
(define (totalmass particles)
  (define (op x y) (+ y (particle-mass x)))
  (foldr op 0 particles))
;;sum of two vectors
(define (sumv v1 v2)
  (vec (+ (vec-x v1) (vec-x v2)) (+ (vec-y v1) (vec-y v2))))
(define (scale v1 f)
  (vec (* f (vec-x v1)) (* f (vec-y v1))))
;;centre of mass co-ordinates of square
(define (centroid pl)
  (scale (foldr (lambda(x y) (sumv (scale (particle-posn x) (particle-mass x)) y)) (vec 0.0 0.0)  pl)
         (/ 1.0 (totalmass pl))))
;;buildTree fn-it doen't include empty square.
(define (buildTree area particles)
  (cond ((singleton particles) (gnode (particle-mass (car particles)) (particle-posn (car particles)) null))
        (#t (let* ((sep (seperate area particles))
                   (a1  (bbox (bbox-llx area) (/ (+ (bbox-lly area) (bbox-ruy area)) 2) (/ (+ (bbox-llx area) (bbox-rux area)) 2)
                              (bbox-ruy area)))
                   (a2 (bbox (/ (+ (bbox-llx area) (bbox-rux area)) 2) (/ (+ (bbox-lly area) (bbox-ruy area)) 2)
                             (bbox-rux area) (bbox-ruy area)))
                   (a3 (bbox (bbox-llx area) (bbox-lly area) (/ (+ (bbox-llx area) (bbox-rux area)) 2) (/ (+ (bbox-lly area)
                                                                                                             (bbox-ruy area)) 2 )))
                   (a4 (bbox (/ (+ (bbox-llx area) (bbox-rux area)) 2) (bbox-lly area) (bbox-rux area) (/ (+ (bbox-lly area)
                                                                                                             (bbox-ruy area)) 2))))
              (gnode (totalmass particles) (centroid particles)
                     (map (lambda(x) (buildTree (car x) (cdr x))) (filter (lambda(x) (if(null? (cdr x)) #f #t))
                                                                          (zipwith cons (list a1 a2 a3 a4) sep))))))))
;calculating Forces on all particles
(define (calcForces area tree particles)
  (define len (- (bbox-rux area) (bbox-llx area)))
  (define (force p1 l tree)
    (let* ((x12 (- (vec-x (gnode-posn tree)) (vec-x (particle-posn p1))))
           (y12 (- (vec-y (gnode-posn tree)) (vec-y (particle-posn p1))))
           (a (+ (* x12 x12) (* y12 y12))))
      (cond ((and (equal? (particle-mass p1) (gnode-mass tree)) (equal? (particle-posn p1) (gnode-posn tree))) (vec 0.0 0.0))
            ((or (> (/ (sqrt a) l) theta) (null? (gnode-subtrees tree)))
             (vec (* (/ (* g (particle-mass p1) (gnode-mass tree)) a) (cos (atan y12 x12)))
                  (* (/ (* g (particle-mass p1) (gnode-mass tree)) a) (sin (atan y12 x12)))))
            (#t (foldr (lambda(x y) (cond (#t (let ((a (force p1 (/ l 2) x)))
                                                (vec (+ (vec-x a) (vec-x y)) (+ (vec-y a) (vec-y y)))))))
                       (vec 0.0 0.0) (gnode-subtrees tree))))))
  (foldr (lambda(x y) (cons (force x len tree) y)) '() particles))
;;moveparticles:-gives configuration after a time-slice
(define (moveparticles particles forces)
  (zipwith moving particles forces))
(define (moving a b)
  (let* ((m (particle-mass a))
         (pos (particle-posn a))
         (v (particle-velocity a))
         (acc (vec (/ (vec-x b) m) (/ (vec-y b) m))))
    (particle m (vec (+ (vec-x pos) (+ (* (vec-x v) timeslice) (* .5 (vec-x acc) timeslice timeslice))) (+ (vec-y pos) (+ (* (vec-y v) timeslice) (* .5 (vec-y acc) timeslice timeslice))))
              (vec (+ (vec-x v) (* (vec-x acc) timeslice)) (+ (vec-y v) (* (vec-y acc) timeslice))))))